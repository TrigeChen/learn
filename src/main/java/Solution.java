import com.sun.org.apache.bcel.internal.generic.SWAP;import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;/** * ClassName: Solution * Package: PACKAGE_NAME * Description: * * @Author CYT * @Create 2024/4/16 19:07 * @Version 1.0 */public class Solution {}class Solution1{    public static void main(String[] args) {        String str = "youyouyou";        int count = minChar(str);        System.out.println(count);    }    public static int minChar(String str){        int length = str.length();        int count = 0;        char[] chars = str.toCharArray();        for (int i = 1; i < length ; i++) {            if(chars[i-1] == 'y' && chars[i] == 'u'){                count++;            }        }        return count;    }}class Solution2{    public static int maxMatches(int n,int[] a, int[] b, int[] c) {        int matches = 0;        for (int i = 0; i < n; i++) {            if(a[i] + b[i] == c[i]){                matches++;            }else{                int num = a[i] + b[i];                for (int j = 0;j < n;j++){                    if(num == c[j]){                        int temp = c[i];                        c[i] = c[j];                        c[j] = temp;                        matches++;                    }                }            }        }        return matches;    }    public static void main(String[] args) {        int[] a = {1, 2, 3, 4};        int[] b = {2, 3, 4, 5};        int[] c = {4, 5, 6, 7};        int maxMatches = maxMatches(4,a, b, c);        System.out.println("最大匹配数量：" + maxMatches);    }}class PrimeNumberMerge {    // 是否为素数    public static boolean isPrime(int n) {        if (n <= 1) {            return false;        }        for (int i = 2; i <= Math.sqrt(n); i++) {            if (n % i == 0) {                return false;            }        }        return true;    }    // 找数组中的所有素数    public static ArrayList<Integer> findPrimes(int[] arr) {        ArrayList<Integer> primes = new ArrayList<>();        for (int num : arr) {            if (isPrime(num)) {                primes.add(num);            }        }        return primes;    }    // 合并    public static int[] mergePrimes(int[] arr) {        ArrayList<Integer> primes = findPrimes(arr);        ArrayList<Integer> merged = new ArrayList<>();        for (int i = 0; i < arr.length; i++) {            if (!primes.contains(arr[i])) {                merged.add(arr[i]);                continue;            }            if (i < arr.length - 1 && primes.contains(arr[i + 1])) {                int mergedNum = arr[i] + arr[i + 1];                merged.add(mergedNum);                i++;            } else {                merged.add(arr[i]);            }        }        int[] result = new int[merged.size()];        for (int i = 0; i < merged.size(); i++) {            result[i] = merged.get(i);        }        return result;    }    public static void main(String[] args) {        int[] arr = {1,3,2,5,4};        while (true) {            int[] mergedArr = mergePrimes(arr);            if (mergedArr.length == arr.length) {                break;            }            arr = mergedArr;        }        System.out.println("最终数组：");        for (int num : arr) {            System.out.print(num + " ");        }        System.out.println();        System.out.println("数组长度为：");        System.out.println(arr.length);    }}class Soultion3{    static List<List<Integer>> graph;    static boolean[] visited;    static int[] depth;    static int diameter;    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        sc.nextLine();        graph = new ArrayList<>();        visited = new boolean[n];        depth = new int[n];        for (int i = 0;i < n;i++){            graph.add(new ArrayList<Integer>());        }        for(int i = 0;i < n-1;i++){            int u = sc.nextInt() - 1;            int v = sc.nextInt() - 1;            sc.nextLine();            graph.get(u).add(v);            graph.get(v).add(u);        }        diameter = 0;        dfs(0,-1,0);        for (int i = 0; i < n; i++) {            System.out.println("f(" + (i+1) + ") = " + calculateFi(i, -1, 0));        }    }    static void dfs(int node, int parent, int currentDepth) {        visited[node] = true;        depth[node] = currentDepth;        for (int neighbor : graph.get(node)) {            if (neighbor != parent && !visited[neighbor]) {                dfs(neighbor, node, currentDepth + 1);            }        }        // 更新树的直径        diameter = Math.max(diameter, currentDepth);    }    // 计算每个节点的f(i)值    static int calculateFi(int node, int parent, int parentDepth) {        int maxDepth = depth[node];        for (int neighbor : graph.get(node)) {            if (neighbor != parent) {                maxDepth = Math.max(maxDepth, calculateFi(neighbor, node, depth[node] + 1));            }        }        // 根据定义，f(i) = 对i节点上再连接一个新的叶子节点后，树的直径长度        // 所以 f(i) = max(树的直径长度, parentDepth + 1)        return Math.max(maxDepth, parentDepth + 1);    }//    public static int[] dfs(int node,int parent){//        visited[node] = true;//        int maxDepth = 0;//        int diameter = 0;////        for(int neighbor : graph.get(node)){//            if(neighbor!=parent){//                if(!visited[neighbor]) {//                    int[] result = dfs(neighbor, node);//                    maxDepth = Math.max(maxDepth, result[0]);//                    diameter = Math.max(diameter, result[1]);////                }//            }//        }//        depth[node] = maxDepth + 1;//        int f1 = Math.max(maxDepth,diameter + 1);//        diameter = Math.max(diameter,maxDepth + 1);//        return new int[]{depth[node],diameter,f1};//    }}